## canvas 能做什么
- 画线段、矩形、圆、圆弧、椭圆、贝塞尔曲线、文本，其余图形要么是多边形（只能由多条线段来画）要么贴图，这是一切绘制的基础
- canvas 没有状态，相当于 n 幅画快速切换，所以绘制的图形得自己保存起来，任何点选事件都得遍历我们保存的数据，通过各种计算判断选择了哪一个对象
- canvas 操作的是图形吗？不是，操作的是数据和坐标系

## canvas 中的技巧
- 坐标系变化（简化了计算又方便了绘制）
- 向量化（计算方便）
- 裁剪
- 局部渲染
- 离屏 canvas
- 像素计算（web worker、gpu.js、webassembly）

## 贝塞尔曲线
讲的的不错
https://juejin.cn/post/6844903760007790600
https://juejin.cn/post/6939742079295848462#heading-21

反求 t 值
1、公式法
2、二分法
3、先切分成 n 份

## 图形库skia剖析
https://juejin.cn/post/6914188284126035981

## 核心动画编程指南
https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/CoreAnimationBasics/CoreAnimationBasics.html#//apple_ref/doc/uid/TP40004514-CH2-SW3

## 高性能Web动画和渲染原理系列
https://developer.huawei.com/consumer/cn/doc/search?type=forum&val=%E9%AB%98%E6%80%A7%E8%83%BDWeb%E5%8A%A8%E7%94%BB%E5%92%8C%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E7%B3%BB%E5%88%97

## svg、canvas 和 webgl
不错的文章：https://juejin.cn/post/6912086785405386765
- Canvas 能够直接操作绘图上下文，不需要经过 HTML、CSS 解析、构建渲染树、布局等一系列操作。因此单纯绘图的话，Canvas 比 HTML/CSS 和 SVG 要快得多、在重绘图像时，也不会发生重新解析文档和构建结构的过程，开销要小很多。
- 如果我们要绘制的图形数量非常多，比如有多达数万个几何图形需要绘制，而且它们的位置和方向都在不停地变化，如果使用 Canvas2D 绘制，性能是会达到瓶颈的。这个时候，我们就需要使用 GPU 能力，直接用 WebGL 来绘制。
- 如果我们要对较大图像的细节做像素处理，比如，实现物体的光影、流体效果和一些复杂的像素滤镜。由于这些效果往往要精准地改变一个图像全局或局部区域的所有像素点，要计算的像素点数量非常的多（一般是数十万甚至上百万数量级的），我们也要用 WebGL 来绘制。
- WebGL 内置了对 3D 物体的投影、深度检测等特性，所以用它来渲染 3D 物体就不需要我们自己对坐标做底层的处理了。在这种情况下，WebGL 无论是在使用上还是性能上都有很大优势。
- 数据经过CPU（中央处理单元，负责逻辑计算）处理，成为具有特定结构的几何信息。然后，信息会被送到GPU（图形处理单元，负责图形计算）中进行处理。在GPU中要经过两个步骤生成光栅信息（构成图像的像素矩阵），这些光栅信息会输出到帧缓存（一块内存地址）中，最后渲染到屏幕上。
GPU 是由大量的小型处理单元构成的，它可能远远没有 CPU 那么强大，但胜在数量众多，可以保证每个单元处理一个简单的任务。即使我们要处理一张 800 * 600 大小的图片，GPU 也可以保证这 48 万个像素点分别对应一个小单元，这样我们就可以同时对每个像素点进行计算了。

## 将用户画出的复杂图形分割成基本的图元。
分割的好坏会直接影响到后面识别的部分。
曲率：曲线上各点沿曲线方向的变化情况，借助曲率可以刻画曲线的几何特征。
- 曲率 - 几何特征
- 连续零曲率 - 直线段
- 连续非零曲率 - 弧线段
- 局部最大曲率绝对值 - 角点
- 局部最大曲率正值 - 凸角点
- 局部最大曲率负值 - 凹角点
- 曲率过零点 - 特征点 

## 判断图形相似度
两个图形相似，那么其总可以将一个图形乘以一定的倍数，使两个图形全等。
所有的方法，都必须要构建大小差不多的两个图形。可以要计算原始图形的 boundingBox，与绘制的图形 boundingBox，然后将他们归一化到相同的大小。

有了归一化的图形，接下来就是要怎么计算他们的相似度，有两个方法：

比较挫的方法：求两个图形之间交集，差集等，然后分配一定的权重来计算，有一些 JS 库提供了求交、差、补的方法，比如供 Three.js 使用的 ThreeBSP
对图形的外边框进行分割采样，然后计算采样点偏离的方差
当然还有更高大上的方式，比如将两个图形进行填充，然后逐像素比对，求汉明距离。
还可以对图形进行特征值提取比对，甚至深入了机器学习领域。

## 手绘风格的 canvas
### 思路
- 一条直线用两条贝塞尔曲线绘制
- 填充算法：扫描线填充和种子填充
### 参考文章
https://juejin.cn/post/6942262577460314143

### 两大手绘风格图形库
https://app.diagrams.net/
https://excalidraw.com/?from=thosefree.com

## 以图搜图
均值哈希（像素域） || 感知哈希（频率域） || 颜色分布直方图 || 灰度二值化（RGB权重不同）
### 方法一（适合缩略图搜原图）：
1. 第一步，缩小尺寸。
将图片缩小到8x8的尺寸，总共64个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。
2. 第二步，简化色彩。
将缩小后的图片，转为64级灰度。也就是说，所有像素点总共只有64种颜色。
3. 第三步，计算平均值。
计算所有64个像素的灰度平均值。
4. 第四步，比较像素的灰度。
将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为1；小于平均值，记为0。
5. 第五步，计算哈希值。
将上一步的比较结果，组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。如8f373714acfcf4d0
6. 得到指纹以后，就可以对比不同的图片，看看64位中有多少位是不一样的。
在理论上，这等同于计算"汉明距离"（Hamming distance）。如果不相同的数据位不超过5，就说明两张图片很相似；如果大于10，就说明这是两张不同的图片。


### 方法二：
如果每种原色都可以取256个值，那么整个颜色空间共有1600万种颜色（256的三次方）。针对这1600万种颜色比较直方图，计算量实在太大了，因此需要采用简化方法。可以将0～255分成四个区：0～63为第0区，64～127为第1区，128～191为第2区，192～255为第3区。这意味着红绿蓝分别有4个区，总共可以构成64种组合（4的3次方）。
1. 计算每种颜色的像素数量
2. 把计算的数量按序组成一个64维向量(7414, 230, 0, 0, 8, ..., 109, 0, 0, 3415, 53929)。这个向量就是这张图片的特征值或者叫"指纹"。

### 参考文章
- https://www.ruanyifeng.com/blog/2011/07/principle_of_similar_image_search.html
- https://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html
- https://juejin.cn/post/6844904018830065671#heading-1


## 子图布局的实现方式、力导向图、紧凑树布局
- https://juejin.cn/post/7074929597812326430?utm_source=gold_browser_extension
- https://juejin.cn/post/6920183250833014797

力导布局的优势在于由于互斥力的存在，可以减少节点之间的重叠，但实际上当节点过多时，仍然会出现节点重叠的情况，在有限的空间里想要避免所有节点不重叠，这已被证明是一个 NP 难题（世界难题，目前无解）。



## Excel 的实现方式
- AntV S2 写的不错 https://juejin.cn/post/7072926133859123236?utm_source=gold_browser_extension#heading-1
- AntV S2 的官网说明也能学到不少 https://s2.antv.vision/zh/examples/case/performance-compare#table
